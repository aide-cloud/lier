"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const glob_1 = __importDefault(require("glob"));
const webpack_sources_1 = require("webpack-sources");
const parseComment_1 = __importDefault(require("./parseComment"));
const parseRawComment_1 = __importDefault(require("./parseRawComment"));
const parseModuleExport_1 = __importDefault(require("./parseModuleExport"));
const tryGetUMDInfo_1 = __importDefault(require("../utils/tryGetUMDInfo"));
const constant_1 = require("../constant");
const encodeInfo_1 = __importDefault(require("../utils/encodeInfo"));
const getTitleOfMarkdown_1 = __importDefault(require("../utils/getTitleOfMarkdown"));
const parseMarkdownTitle_1 = __importDefault(require("./parseMarkdownTitle"));
const removeMarkdownDemoPart_1 = __importDefault(require("../utils/removeMarkdownDemoPart"));
class ArcoSiteModuleInfoPlugin {
    constructor(options) {
        options = options || {};
        const { globs } = options;
        let docPathList = [];
        let demoPathList = [];
        const extendPathList = ({ doc, component } = { doc: null, component: null }) => {
            if (doc) {
                docPathList = docPathList.concat(glob_1.default.sync(path_1.default.resolve(doc)));
            }
            if ((component === null || component === void 0 ? void 0 : component.base) && (component === null || component === void 0 ? void 0 : component.demo)) {
                demoPathList = demoPathList.concat(glob_1.default.sync(path_1.default.resolve(component.base, component.demo)));
            }
        };
        if (globs) {
            if (Array.isArray(globs)) {
                globs.forEach((item) => extendPathList(item));
            }
            else if (typeof globs === 'object' && !globs.component && !globs.doc) {
                Object.entries(globs).forEach(([_, item]) => extendPathList(item));
            }
            else {
                extendPathList(globs);
            }
        }
        this.paths = {
            doc: docPathList,
            demo: demoPathList,
        };
    }
    /**
     * Get module info like
     * {
     *   zh-CN: [
     *     {
     *       key: 'submodule_1',
     *       components: [ { name: 'Button', info: {}, children: [] } ],
     *       documents: [ { name: 'Doc_1', info: {}, isDoc: true } ]
     *     }
     *   ]
     * }
     */
    getModuleInfoMap({ chunkInfoList, moduleExportInfoMap, }) {
        // Parse raw comment
        const rawDemoCommentMap = {};
        this.paths.demo.forEach((demoPath) => {
            rawDemoCommentMap[demoPath] = (0, parseRawComment_1.default)(fs_1.default.readFileSync(demoPath, 'utf-8'));
        });
        const moduleInfoMap = {};
        for (const { name: chunkName, entry } of chunkInfoList) {
            if (!moduleExportInfoMap[entry]) {
                continue;
            }
            // Parse comment of target language
            const demoCommentMap = {};
            Object.entries(rawDemoCommentMap).forEach(([demoPath, commentList]) => {
                demoCommentMap[demoPath] = commentList.map((comment) => {
                    // memberof and memberOf both works fine
                    if (comment.memberof) {
                        comment.memberOf = comment.memberof;
                    }
                    return (0, parseComment_1.default)({
                        comment,
                        targetLanguage: chunkName,
                    });
                });
            });
            const moduleInfo = [];
            // Inject comment for module info
            // [entry] is the entry file for webpack building
            moduleExportInfoMap[entry].forEach(({ name, dependencies }) => {
                var _a, _b;
                // Submodule info for pure document imported by buildConfig.glob.doc
                const pureDocSubmodules = moduleExportInfoMap[(_a = dependencies.find(({ key }) => key === 'doc')) === null || _a === void 0 ? void 0 : _a.path];
                // Submodule info for component imported by buildConfig.glob.component
                const componentSubmodules = moduleExportInfoMap[(_b = dependencies.find(({ key }) => key === 'component')) === null || _b === void 0 ? void 0 : _b.path];
                if (!pureDocSubmodules && !componentSubmodules) {
                    return;
                }
                const submoduleInfo = {
                    key: name,
                    doc: [],
                    component: [],
                };
                if (pureDocSubmodules) {
                    pureDocSubmodules.forEach(({ name, dependencies }) => {
                        const { path: documentPath, rawCode: documentContent } = dependencies.find(({ path }) => this.paths.doc.indexOf(path) > -1) || {};
                        if (documentPath) {
                            submoduleInfo.doc.push({
                                name,
                                isDoc: true,
                                info: {
                                    name: (0, getTitleOfMarkdown_1.default)(dependencies[0].path),
                                },
                                outline: (0, parseMarkdownTitle_1.default)(documentContent),
                            });
                        }
                    });
                }
                if (componentSubmodules) {
                    componentSubmodules.forEach(({ name, dependencies }) => {
                        var _a, _b;
                        const demoEntryPath = (_a = dependencies.find(({ path }) => this.paths.demo.indexOf(path) > -1)) === null || _a === void 0 ? void 0 : _a.path;
                        const demoSubmodules = moduleExportInfoMap[demoEntryPath];
                        const commentList = demoCommentMap[demoEntryPath];
                        const componentInfo = Object.assign(Object.assign({}, ((commentList === null || commentList === void 0 ? void 0 : commentList[0]) || {})), { umd: (0, tryGetUMDInfo_1.default)(demoEntryPath) });
                        const demoCommentList = commentList ? commentList.slice(-demoSubmodules.length) : [];
                        const demoInfoList = demoSubmodules.map(({ name, value, dependencies }, index) => {
                            var _a;
                            return {
                                name,
                                rawCode: ((_a = dependencies[0]) === null || _a === void 0 ? void 0 : _a.rawCode) || value,
                                info: demoCommentList[index] || {},
                            };
                        });
                        const apiDocument = (0, parseMarkdownTitle_1.default)((0, removeMarkdownDemoPart_1.default)(((_b = dependencies.find(({ path }) => path.endsWith('.md'))) === null || _b === void 0 ? void 0 : _b.rawCode) || ''));
                        submoduleInfo.component.push({
                            name,
                            info: componentInfo,
                            children: demoInfoList,
                            outline: [
                                ...demoInfoList.map(({ name, info }) => ({
                                    depth: 2,
                                    text: (info === null || info === void 0 ? void 0 : info.title) || (info === null || info === void 0 ? void 0 : info.name) || name,
                                })),
                                ...apiDocument,
                            ],
                        });
                    });
                }
                moduleInfo.push(submoduleInfo);
            });
            moduleInfoMap[chunkName] = moduleInfo;
        }
        return moduleInfoMap;
    }
    apply(compiler) {
        let moduleExportInfoMap = {};
        let hasInjectedModuleInfo = false;
        const chunkInfoList = [];
        const getNewSource = (source, moduleInfo) => {
            return source.replace(new RegExp(constant_1.PLACEHOLDER_ARCO_SITE_MODULE_INFO, 'g'), (0, encodeInfo_1.default)(moduleInfo));
        };
        compiler.hooks.compilation.tap('ArcoSiteModuleInfoPlugin', (compilation) => {
            compilation.hooks.optimizeModules.tap('ArcoSiteModuleInfoPlugin', () => {
                const chunkList = [...compilation.chunks];
                chunkList.forEach((chunk) => {
                    if (compilation.chunkGraph !== undefined) {
                        for (const module of compilation.chunkGraph.getChunkEntryModulesIterable(chunk)) {
                            if (module.resource.indexOf('/node_modules/') === -1) {
                                chunkInfoList.push({
                                    name: chunk.name,
                                    entry: module.resource,
                                });
                            }
                        }
                    }
                    else {
                        const { name, entryModule } = chunk;
                        chunkInfoList.push({
                            name,
                            entry: entryModule.resource,
                        });
                    }
                });
                // Parse the export module info of demo files
                moduleExportInfoMap = (0, parseModuleExport_1.default)({
                    context: compiler.context,
                    validPaths: this.paths.demo.concat(glob_1.default.sync(path_1.default.resolve(path_1.default.dirname(chunkInfoList[0].entry), '**/*'))),
                    statsModules: compilation.getStats().toJson({
                        source: true,
                        providedExports: true,
                    }).modules,
                });
            });
            // [Webpack5] Needs to process resource content in processAssets
            if (compilation.hooks.processAssets) {
                compilation.hooks.processAssets.tap('ArcoSiteModuleInfoPlugin', (assets) => {
                    var _a;
                    const moduleInfoMap = this.getModuleInfoMap({
                        moduleExportInfoMap,
                        chunkInfoList,
                    });
                    for (const filename in assets) {
                        if (assets.hasOwnProperty(filename) && filename.endsWith('.js')) {
                            const chunkName = Object.keys(compiler.options.entry).find((chunkName) => {
                                return filename.indexOf(`.${chunkName}.`) > -1;
                            });
                            const targetModuleInfo = moduleInfoMap[chunkName] || ((_a = Object.entries(moduleInfoMap)[0]) === null || _a === void 0 ? void 0 : _a[1]);
                            if (targetModuleInfo) {
                                compilation.updateAsset(filename, new webpack_sources_1.RawSource(getNewSource(assets[filename].source(), targetModuleInfo)));
                            }
                        }
                    }
                    hasInjectedModuleInfo = true;
                });
            }
        });
        // [Webpack4] Processes the final result during emit
        compiler.hooks.emit.tapPromise('ArcoSiteModuleInfoPlugin', (compilation) => __awaiter(this, void 0, void 0, function* () {
            if (hasInjectedModuleInfo) {
                return;
            }
            // Supplement the asset file name information in chunkInfo
            compilation.chunks.forEach(({ name, files }) => {
                const info = chunkInfoList.find((i) => i.name === name);
                if (info) {
                    info.files = files;
                }
            });
            const moduleInfoMap = this.getModuleInfoMap({
                chunkInfoList,
                moduleExportInfoMap,
            });
            chunkInfoList.forEach(({ name: chunkName, files }) => {
                // Inject the extracted module information
                files &&
                    files.forEach((file) => {
                        if (moduleInfoMap[chunkName]) {
                            const asset = compilation.assets[file];
                            const source = asset.source();
                            asset.source = () => getNewSource(source, moduleInfoMap[chunkName]);
                        }
                    });
            });
        }));
    }
}
exports.default = ArcoSiteModuleInfoPlugin;
// Don't delete this, make sure direct require is available
module.exports = ArcoSiteModuleInfoPlugin;

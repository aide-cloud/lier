"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPathEntryByLanguage = exports.LIBRARY_MODULE_NAME = exports.ENTRY_DIR_NAME = void 0;
const axios_1 = __importDefault(require("axios"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const ora_1 = __importDefault(require("ora"));
const glob_1 = __importDefault(require("glob"));
const glob_parent_1 = __importDefault(require("glob-parent"));
const arco_cli_dev_utils_1 = require("arco-cli-dev-utils");
const locale_1 = __importDefault(require("../locale"));
const getMainConfig_1 = __importDefault(require("./getMainConfig"));
const constant_1 = require("../constant");
const getTitleOfMarkdown_1 = __importDefault(require("./getTitleOfMarkdown"));
const getSubmodulePath_1 = __importDefault(require("./getSubmodulePath"));
const getArcoHost_1 = __importDefault(require("./getArcoHost"));
const getFilenameByLanguage_1 = __importDefault(require("./getFilenameByLanguage"));
exports.ENTRY_DIR_NAME = '.temp';
exports.LIBRARY_MODULE_NAME = 'arcoSite';
const VARIABLE_PREFIX = exports.LIBRARY_MODULE_NAME;
const FUNCTION_LABEL = '#FUNC#';
const FILE_CONTENT_PREFIX = [
    `/* Do NOT edit this file manually, it's generated by arco-material-doc-site. */`,
    `/* eslint-disable */`,
];
const { build: buildConfig, site: siteConfig, group: groupInfo } = (0, getMainConfig_1.default)();
const entryFileDir = path_1.default.resolve(exports.ENTRY_DIR_NAME);
/**
 * Get specific file path by language as webpack build entry
 */
function getPathEntryByLanguage(language) {
    return path_1.default.resolve(entryFileDir, `index.js`.replace(/.js$/, `.${language}.js`));
}
exports.getPathEntryByLanguage = getPathEntryByLanguage;
function transformObjectToExpression(obj) {
    return (JSON.stringify(obj || {}, null, 2)
        .replace(/^"(.*)"$/s, (_, $1) => $1)
        // Convert "#FUNC#() => true;#FUNC#" to () => true;
        .replace(new RegExp(`"?${FUNCTION_LABEL}"?`, 'g'), ''));
}
function generateDocTree(options) {
    var _a, _b;
    const { entry, baseDir, filter, onFile } = options;
    const result = [];
    const files = fs_extra_1.default.readdirSync(entry);
    for (const file of files) {
        const filePath = path_1.default.resolve(entry, file);
        const filePathToBaseDir = `/${path_1.default.relative(baseDir, filePath)}`;
        const stats = fs_extra_1.default.lstatSync(filePath);
        const isFile = stats.isFile();
        const isDirectory = stats.isDirectory();
        if (isFile) {
            if (!filter || filter(filePath)) {
                const info = {
                    name: (0, getTitleOfMarkdown_1.default)(filePath),
                    path: filePathToBaseDir,
                };
                result.push(info);
                onFile(filePath, info);
            }
        }
        if (isDirectory) {
            result.push({
                name: file,
                path: filePathToBaseDir,
                children: generateDocTree(Object.assign(Object.assign({}, options), { entry: filePath })),
            });
        }
    }
    const relativePath = path_1.default.relative(baseDir, entry) || '/';
    const sortRule = (_b = (_a = siteConfig === null || siteConfig === void 0 ? void 0 : siteConfig.menu) === null || _a === void 0 ? void 0 : _a.sortRule) === null || _b === void 0 ? void 0 : _b[relativePath];
    if (Array.isArray(sortRule)) {
        return result.sort(({ name: nameA }, { name: nameB }) => {
            const indexA = sortRule.indexOf(nameA);
            const indexB = sortRule.indexOf(nameB);
            if (indexA > -1 && indexB > -1) {
                return indexA > indexB ? 1 : -1;
            }
            return indexB > -1 ? 1 : -1;
        });
    }
    return result;
}
function extendSiteConfigFromRemoteGroupSetting() {
    return __awaiter(this, void 0, void 0, function* () {
        // Try to get arcoDesignLabTheme from remote group settings
        if ((groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.id) && !siteConfig.arcoDesignLabTheme) {
            try {
                const arcoHost = yield (0, getArcoHost_1.default)(groupInfo.private);
                const spinner = (0, ora_1.default)();
                spinner.start(locale_1.default.TIP_USE_THEME_FROM_REMOTE_GROUP_CONFIG_ING);
                const { data: { result: [{ theme, name: groupName }], }, } = yield axios_1.default.post(`${arcoHost}/material/api/group/`, {
                    id: groupInfo.id,
                });
                if (theme) {
                    spinner.succeed(locale_1.default.TIP_USE_THEME_FROM_REMOTE_GROUP_CONFIG_DONE(groupName, theme));
                    siteConfig.arcoDesignLabTheme = theme;
                }
                else {
                    spinner.succeed(locale_1.default.TIP_USE_THEME_FROM_REMOTE_GROUP_CONFIG_FAIL);
                }
            }
            catch (err) {
                arco_cli_dev_utils_1.print.error('[arco-doc-site]', `Failed to extend group configuration of group-${groupInfo.id} from remote`);
                console.error(err);
            }
        }
    });
}
/**
 * Generate submodule of entry file
 */
function generateSubmodules(submodulePathInfo, language) {
    let documentInfo = [];
    Object.entries(submodulePathInfo).forEach(([key, { glob: globConfig, path: submoduleEntryRelativePath }]) => {
        submoduleEntryRelativePath =
            typeof submoduleEntryRelativePath === 'object'
                ? submoduleEntryRelativePath[language]
                : submoduleEntryRelativePath;
        const exportModuleInfoList = [];
        const fileContent = [...FILE_CONTENT_PREFIX];
        const submoduleEntryPath = path_1.default.resolve(entryFileDir, submoduleEntryRelativePath);
        const getRelativePathForImport = (absolutePath) => {
            return path_1.default
                .relative(path_1.default.dirname(submoduleEntryPath), absolutePath)
                .replace(/^[^.]/, (str) => `./${str}`);
        };
        switch (key) {
            case 'doc': {
                // Glob info about pure document
                const globDocBasePath = (0, glob_parent_1.default)(globConfig);
                const globDocMagicPath = globConfig.replace(`${globDocBasePath}/`, '');
                const docEntryPathWithLanguage = path_1.default.resolve(globDocBasePath, language);
                const docEntryPath = fs_extra_1.default.existsSync(docEntryPathWithLanguage)
                    ? docEntryPathWithLanguage
                    : globDocBasePath;
                const validDocPathList = glob_1.default.sync(path_1.default.resolve(docEntryPath, globDocMagicPath));
                documentInfo = generateDocTree({
                    entry: docEntryPath,
                    baseDir: docEntryPath,
                    filter: (filePath) => validDocPathList.indexOf(filePath) > -1,
                    onFile: (filePath, info) => {
                        const componentName = `Doc${validDocPathList.indexOf(filePath)}`;
                        const statement = `_${componentName}`;
                        // import document
                        fileContent.push(`\n// Import document from ${filePath}`);
                        fileContent.push(`import * as ${statement} from '${getRelativePathForImport(filePath)}';\n`);
                        // export document
                        exportModuleInfoList.push({
                            name: componentName,
                            statement,
                        });
                        // write component name of document to docInfo
                        info.moduleName = componentName;
                    },
                });
                break;
            }
            case 'hook': {
                Object.entries(globConfig).forEach(([hookName, hookPattern]) => {
                    const [hookPath] = glob_1.default.sync(hookPattern);
                    if (hookPath) {
                        fileContent.push(`export { default as ${hookName} } from '${getRelativePathForImport(hookPath)}';`);
                    }
                });
                break;
            }
            case 'component': {
                glob_1.default
                    .sync(globConfig.base)
                    .map((p) => {
                    const { demo, doc, style } = globConfig;
                    return {
                        componentName: path_1.default
                            .basename(p)
                            .replace(/(?:-|^)(\w)/g, (_, $1) => $1.toUpperCase())
                            .replace(/[^a-z1-9]/gi, ''),
                        pathDemo: demo && path_1.default.resolve(p, (0, getFilenameByLanguage_1.default)(demo, language)),
                        pathDoc: doc && path_1.default.resolve(p, (0, getFilenameByLanguage_1.default)(doc, language)),
                        pathStyle: style && path_1.default.resolve(p, style),
                    };
                })
                    .forEach(({ componentName: moduleName, pathDemo, pathDoc, pathStyle }) => {
                    let demoModuleName;
                    let docModuleName;
                    const tempFileContent = [`// Import demos and document of ${moduleName}`];
                    if (fs_extra_1.default.existsSync(pathDemo)) {
                        demoModuleName = `_${moduleName}`;
                        tempFileContent.push(`import * as ${demoModuleName} from '${getRelativePathForImport(pathDemo)}';`);
                    }
                    if (fs_extra_1.default.existsSync(pathDoc)) {
                        docModuleName = `_${moduleName}Doc`;
                        tempFileContent.push(`import ${docModuleName} from '${getRelativePathForImport(pathDoc)}';`);
                    }
                    if (buildConfig.withMaterialStyle && fs_extra_1.default.existsSync(pathStyle)) {
                        tempFileContent.push(`import '${pathStyle}';`);
                    }
                    if (demoModuleName || docModuleName) {
                        fileContent.push(`\n${tempFileContent.join('\n')}\n`);
                        exportModuleInfoList.push({
                            name: moduleName,
                            statement: `{ ${demoModuleName ? `...${demoModuleName}, ` : ''}${docModuleName ? `_SITE_DOC: ${docModuleName} ` : ''}}`,
                        });
                    }
                });
                break;
            }
            default:
        }
        const exportExpressions = exportModuleInfoList
            .map(({ name, statement }) => {
            return `export const ${name} = ${statement};\n`;
        })
            .join('\n');
        fileContent.push(`\n// Export Modules\n${exportExpressions}`);
        fs_extra_1.default.ensureDirSync(path_1.default.dirname(submoduleEntryPath));
        fs_extra_1.default.writeFileSync(submoduleEntryPath, fileContent.join('\n'));
    });
    return documentInfo;
}
/**
 * Generate entry file for webpack build
 */
function generateEntries(submodulePathInfoMap, documentTreeMap, language) {
    var _a;
    // Final content of entry file
    const fileContent = [...FILE_CONTENT_PREFIX];
    // Export statements
    const exportModuleInfoList = [];
    Object.entries(submodulePathInfoMap).forEach(([key, submoduleInfo]) => {
        const statement = {};
        Object.entries(submoduleInfo).forEach(([innerKey, { path: submoduleEntryRelativePath }]) => {
            submoduleEntryRelativePath =
                typeof submoduleEntryRelativePath === 'object'
                    ? submoduleEntryRelativePath[language]
                    : submoduleEntryRelativePath;
            if (fs_extra_1.default.existsSync(path_1.default.resolve(entryFileDir, submoduleEntryRelativePath))) {
                const importName = `${key}_${innerKey}`;
                fileContent.push(`import * as ${importName} from '${submoduleEntryRelativePath}';`);
                statement[innerKey] = importName;
            }
        });
        exportModuleInfoList.push({
            name: key,
            statement: `{ ${Object.entries(statement)
                .map(([k, v]) => `${k}: ${v}`)
                .join(', ')} }`,
        });
    });
    if (buildConfig.customModulePath && fs_extra_1.default.existsSync(buildConfig.customModulePath)) {
        const exportName = `${VARIABLE_PREFIX}CustomModule`;
        fileContent.push(`import * as _${exportName} from '${path_1.default.relative(entryFileDir, path_1.default.resolve(buildConfig.customModulePath))}';`);
        exportModuleInfoList.push({
            name: exportName,
            statement: `_${exportName}`,
        });
    }
    exportModuleInfoList.push({
        name: `${VARIABLE_PREFIX}ModuleInfo`,
        statement: 'decodeInfo(moduleInfoStr)',
    });
    exportModuleInfoList.push({
        name: `${VARIABLE_PREFIX}Config`,
        statement: transformObjectToExpression(siteConfig),
    });
    if (groupInfo) {
        exportModuleInfoList.push({
            name: `${VARIABLE_PREFIX}GroupInfo`,
            statement: transformObjectToExpression(groupInfo),
        });
    }
    exportModuleInfoList.push({
        name: `${VARIABLE_PREFIX}DocumentInfo`,
        statement: transformObjectToExpression(documentTreeMap),
    });
    exportModuleInfoList.push({
        name: `${VARIABLE_PREFIX}ToolVersion`,
        statement: `'${require('../../package.json').version}'`,
    });
    const exportExpressions = exportModuleInfoList
        .map(({ name, statement }) => {
        return `export const ${name} = ${statement};\n${exports.LIBRARY_MODULE_NAME}.${name} = ${name};\n`;
    })
        .join('\n');
    fileContent.push(`
function decodeInfo(infoStr) {
  try {
    const decoder = new TextDecoder();
    const jsonStr = decoder.decode(new Uint8Array(infoStr.split(',')));
    return JSON.parse(jsonStr);
  } catch (e) {}

  return {};
}

const moduleInfoStr = '${constant_1.PLACEHOLDER_ARCO_SITE_MODULE_INFO}';
const ${exports.LIBRARY_MODULE_NAME} = {};

// Export submodules
${exportExpressions}

// Only used by team site development/isolate mode
if (window.arcoMaterialTeamSite && window.arcoMaterialTeamSite.renderPage) {
  const options = ${transformObjectToExpression(Object.assign(Object.assign({}, buildConfig.devOptions), { withArcoStyle: siteConfig.arcoDesignLabTheme
            ? `${FUNCTION_LABEL}() => import('${siteConfig.arcoDesignLabTheme}/css/arco.css')${FUNCTION_LABEL}`
            : (_a = buildConfig.devOptions) === null || _a === void 0 ? void 0 : _a.withArcoStyle }))};
  window.arcoMaterialTeamSite.renderPage(${exports.LIBRARY_MODULE_NAME}, options);
}
`);
    fs_extra_1.default.writeFileSync(getPathEntryByLanguage(language), fileContent.join('\n'));
}
function generateEntryFiles({ isDev } = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const spinner = (0, ora_1.default)();
        yield extendSiteConfigFromRemoteGroupSetting();
        if (!isDev) {
            // Make git ignore temp entry files
            const pathGitIgnore = path_1.default.resolve('.gitignore');
            if (fs_extra_1.default.existsSync(pathGitIgnore)) {
                const gitIgnoreContent = fs_extra_1.default.readFileSync(pathGitIgnore, 'utf8');
                if (gitIgnoreContent.indexOf(exports.ENTRY_DIR_NAME) === -1) {
                    fs_extra_1.default.writeFileSync(pathGitIgnore, gitIgnoreContent.replace(/\n?$/, `\n${exports.ENTRY_DIR_NAME}\n`));
                }
            }
            // Clear entry files
            fs_extra_1.default.removeSync(entryFileDir);
        }
        spinner.start(locale_1.default.TIP_AUTO_GENERATE_ENTRY_FILE_ING);
        fs_extra_1.default.ensureDirSync(entryFileDir);
        // Generate entry files
        const { pathInfoMap: submodulePathInfoMap, globsToWatch } = (0, getSubmodulePath_1.default)(buildConfig, siteConfig.languages);
        siteConfig.languages.forEach((lang) => {
            const documentTreeMap = {};
            Object.entries(submodulePathInfoMap).forEach(([submoduleKey, submoduleInfo]) => {
                documentTreeMap[submoduleKey] = generateSubmodules(submoduleInfo, lang);
            });
            generateEntries(submodulePathInfoMap, documentTreeMap, lang);
        });
        spinner.succeed(locale_1.default.TIP_AUTO_GENERATE_ENTRY_FILE_DONE);
        return [...new Set(globsToWatch)];
    });
}
exports.default = generateEntryFiles;
